<!DOCTYPE html>
<html lang="zh-Hant">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>ä¿„ç¾…æ–¯æ–¹å¡Šé–€å¸‚æ´»å‹•</title>
<style>
  body {
    margin: 0; background: #111; color: #fff; font-family: Arial, sans-serif;
    display: flex; flex-direction: column; align-items: center; min-height: 100vh; text-align: center;
  }
  #home, #game, #end {
    max-width: 400px; width: 100%; padding: 10px; box-sizing: border-box;
    display: none;
  }
  button {
    background: #03a9f4; border: none; color: white; padding: 12px 20px;
    margin: 10px 5px; font-size: 18px; border-radius: 8px; cursor: pointer;
  }
  button:active { background: #0288d1; }
  canvas {
    background: #222; display: block; margin: 20px auto; border: 4px solid #fff;
  }
  #controls { display: flex; justify-content: center; gap: 10px; flex-wrap: wrap; }
  #controls button { flex: 1 1 70px; }
  input, select {
    width: 80%; padding: 10px; margin: 8px 0; border-radius: 6px; border: none; font-size: 16px;
  }
</style>
<script src="https://static.line-scdn.net/liff/edge/2/sdk.js"></script>
</head>
<body>

<!-- é¦–é  -->
<div id="home">
  <h2>ğŸ® ä¿„ç¾…æ–¯æ–¹å¡ŠæŒ‘æˆ°</h2>
  <p>ç©æ³•èªªæ˜ï¼š</p>
  <ul style="text-align:left;">
    <li>ç”¨æŒ‰éˆ•æˆ–éµç›¤æ“ä½œç§»å‹•èˆ‡æ—‹è½‰æ–¹å¡Šã€‚</li>
    <li>æ’åˆ—æ»¿è¡Œæœƒæ¶ˆé™¤ä¸¦å¾—åˆ†ã€‚</li>
    <li>é€Ÿåº¦æœƒéš¨åˆ†æ•¸æå‡ï¼ŒæŒ‘æˆ°æ›´é«˜åˆ†ï¼</li>
    <li>å®ŒæˆæŒ‘æˆ°å³å¯è‡³é–€å¸‚é ˜å–è´ˆå“ï¼</li>
  </ul>
  <button onclick="startMode('500')">ğŸ¯ é”æˆ 500 åˆ†æŒ‘æˆ°</button>
  <button onclick="startMode('3min')">â±ï¸ ä¸‰åˆ†é˜æŒ‘æˆ°</button>
</div>

<!-- éŠæˆ²é  -->
<div id="game">
  <div>åˆ†æ•¸ï¼š<span id="score">0</span></div>
  <div>æ™‚é–“ï¼š<span id="timer">0</span> ç§’</div>
  <canvas id="tetris" width="240" height="400"></canvas>
  <div id="controls">
    <button id="left">â—€ï¸</button>
    <button id="right">â–¶ï¸</button>
    <button id="down">ğŸ”½</button>
    <button id="rotate">ğŸ”„</button>
  </div>
</div>

<!-- çµæŸé  -->
<div id="end">
  <h2>ğŸ‰ æ­å–œå®ŒæˆæŒ‘æˆ°ï¼</h2>
  <p id="result"></p>
  <input id="nickname" type="text" placeholder="è«‹è¼¸å…¥æš±ç¨±ï¼ˆå¿…å¡«ï¼‰" />
  <select id="store">
    <option value="">é¸æ“‡é ˜å–é–€å¸‚ï¼ˆå¿…å¡«ï¼‰</option>
    <option value="æˆå¤§æ ¡åœ’é–€å¸‚">æˆå¤§æ ¡åœ’é–€å¸‚</option>
    <option value="å—è‡ºæ ¡åœ’é–€å¸‚">å—è‡ºæ ¡åœ’é–€å¸‚</option>
  </select>
  <br/>
  <button onclick="submitResult()">æäº¤æˆç¸¾ä¸¦é ˜å–è´ˆå“</button>
</div>

<script>
const LIFF_ID = '2007597530-Dmy8j9mN';  // è«‹æ”¹æˆä½ çš„ LIFF ID
const GAS_URL = 'https://script.google.com/macros/s/AKfycbyWQBO77Eh_n-yXzkpL_IWg4k-jx_5FUOktgpgOcajZ8Bt5g40VDSe66n3k2AwkTnxf/exec';  // è«‹æ”¹æˆä½ çš„ GAS ç¶²å€

let mode = '';
let score = 0;
let timer = 0;
let timerInterval;
let dropInterval = 1000;
let dropCounter = 0;
let lastTime = 0;
let gameOver = false;
let player = { pos: {x:0,y:0}, matrix: null };
let arena = createMatrix(12,20);
const colors = [null,'#FF0D72','#0DC2FF','#0DFF72','#F538FF','#FF8E0D','#FFE138','#3877FF'];

const homeDiv = document.getElementById('home');
const gameDiv = document.getElementById('game');
const endDiv = document.getElementById('end');
const canvas = document.getElementById('tetris');
const context = canvas.getContext('2d');
context.scale(20, 20);

function createMatrix(w, h) { const matrix = []; while (h--) matrix.push(new Array(w).fill(0)); return matrix; }
function createPiece(type) { switch(type){ case 'T': return [[0,0,0],[1,1,1],[0,1,0]]; case 'O': return [[2,2],[2,2]]; case 'L': return [[0,3,0],[0,3,0],[0,3,3]]; case 'J': return [[0,4,0],[0,4,0],[4,4,0]]; case 'I': return [[0,5,0,0],[0,5,0,0],[0,5,0,0],[0,5,0,0]]; case 'S': return [[0,6,6],[6,6,0],[0,0,0]]; case 'Z': return [[7,7,0],[0,7,7],[0,0,0]]; }}
function collide(arena, player) { const [m, o] = [player.matrix, player.pos]; for(let y=0; y<m.length; ++y){ for(let x=0; x<m[y].length; ++x){ if(m[y][x] !== 0 && (arena[y + o.y] && arena[y + o.y][x + o.x]) !== 0){ return true; } } } return false; }
function merge(arena, player) { player.matrix.forEach((row,y) => { row.forEach((value,x) => { if(value !== 0){ arena[y + player.pos.y][x + player.pos.x] = value; } }); }); }
function rotate(matrix, dir) { for(let y=0; y<matrix.length; ++y){ for(let x=0; x<y; ++x){ [matrix[x][y], matrix[y][x]] = [matrix[y][x], matrix[x][y]]; } } if(dir > 0){ matrix.forEach(row => row.reverse()); } else { matrix.reverse(); } }
function playerRotate(dir){ const pos = player.pos.x; let offset = 1; rotate(player.matrix, dir); while(collide(arena, player)){ player.pos.x += offset; offset = -(offset + (offset > 0 ? 1 : -1)); if(Math.abs(offset) > player.matrix[0].length){ rotate(player.matrix, -dir); player.pos.x = pos; return; } } }
function playerDrop() { player.pos.y++; if(collide(arena, player)){ player.pos.y--; merge(arena, player); arenaSweep(); updateScore(); if(mode === '500' && score >= 500){ endGame(); return; } playerReset(); } dropCounter = 0; }
function playerMove(dir) { player.pos.x += dir; if(collide(arena, player)){ player.pos.x -= dir; } }
function playerReset() { const pieces = 'ILJOTSZ'; player.matrix = createPiece(pieces[Math.floor(Math.random() * pieces.length)]); player.pos.y = 0; player.pos.x = Math.floor(arena[0].length / 2) - Math.floor(player.matrix[0].length / 2); if(collide(arena, player)){ arena.forEach(row => row.fill(0)); score = 0; updateScore(); endGame(); } }
function arenaSweep() { let rowCount = 1; outer: for(let y=arena.length -1; y>=0; --y){ for(let x=0; x<arena[y].length; ++x){ if(arena[y][x] === 0){ continue outer; } } const row = arena.splice(y,1)[0].fill(0); arena.unshift(row); score += rowCount * 50; rowCount *= 2; } }
function updateScore() { document.getElementById('score').innerText = score; }
function drawMatrix(matrix, offset){ matrix.forEach((row,y) => { row.forEach((value,x) => { if(value !== 0){ context.fillStyle = colors[value]; context.fillRect(x + offset.x, y + offset.y, 1, 1); } }); }); }
function draw() { context.fillStyle = '#222'; context.fillRect(0, 0, canvas.width, canvas.height); drawMatrix(arena, {x:0, y:0}); drawMatrix(player.matrix, player.pos); }
function update(time = 0){ const deltaTime = time - lastTime; lastTime = time; dropCounter += deltaTime; if(dropCounter > dropInterval){ playerDrop(); } draw(); if(!gameOver){ requestAnimationFrame(update); } }
function startTimer(){ timer = 0; document.getElementById('timer').innerText = timer; timerInterval = setInterval(() => { timer++; document.getElementById('timer').innerText = timer; if(mode === '3min' && timer >= 180){ endGame(); } }, 1000); }
function stopTimer(){ clearInterval(timerInterval); }
function startGame() { arena.forEach(row => row.fill(0)); score = 0; updateScore(); playerReset(); lastTime = 0; dropCounter = 0; dropInterval = 1000; gameOver = false; homeDiv.style.display = 'none'; endDiv.style.display = 'none'; gameDiv.style.display = 'block'; startTimer(); update(); }
function endGame() { stopTimer(); gameOver = true; gameDiv.style.display = 'none'; endDiv.style.display = 'block'; document.getElementById('result').innerText = `éŠæˆ²æ™‚é–“ï¼š${timer} ç§’ï¼Œåˆ†æ•¸ï¼š${score}`; }
document.getElementById('left').addEventListener('click', () => playerMove(-1));
document.getElementById('right').addEventListener('click', () => playerMove(1));
document.getElementById('down').addEventListener('click', () => playerDrop());
document.getElementById('rotate').addEventListener('click', () => playerRotate(1));
document.addEventListener('keydown', event => {
  if(gameOver) return;
  if(event.key === 'ArrowLeft'){ playerMove(-1); }
  else if(event.key === 'ArrowRight'){ playerMove(1); }
  else if(event.key === 'ArrowDown'){ playerDrop(); }
  else if(event.key.toLowerCase() === 'q'){ playerRotate(-1); }
  else if(event.key.toLowerCase() === 'w'){ playerRotate(1); }
});

function startMode(selectedMode){
  mode = selectedMode;
  startGame();
}

async function submitResult() {
  const nicknameInput = document.getElementById('nickname');
  const nickname = nicknameInput.value.trim();
  const store = document.getElementById('store').value.trim();

  if (!nickname) {
    alert('è«‹è¼¸å…¥æš±ç¨±');
    nicknameInput.focus();
    return;
  }
  if (!store) {
    alert('è«‹é¸æ“‡é ˜å–é–€å¸‚');
    return;
  }

  const params = new URLSearchParams({
    nickname: nickname,
    mode: mode === '500' ? 'é”æˆ 500 åˆ†è¨ˆæ™‚æŒ‘æˆ°' : 'ä¸‰åˆ†é˜è¨ˆæ™‚æŒ‘æˆ°',
    score: score.toString(),
    time: timer.toString(),
    store: store
  });

  const requestUrl = `${GAS_URL}?${params.toString()}`;
  console.log('é€å‡ºæˆç¸¾è‡³ï¼š', requestUrl);

  try {
    const res = await fetch(requestUrl, {
      method: 'GET',
    });

    if (!res.ok) {
      throw new Error(`HTTP éŒ¯èª¤ ${res.status}`);
    }

    alert('å·²æˆåŠŸæäº¤ï¼Œè«‹æ”œå¸¶æ‰‹æ©Ÿæˆªåœ–è‡³é–€å¸‚é ˜å–è´ˆå“ï¼');
    location.reload();
  } catch (e) {
    alert('æäº¤å¤±æ•—ï¼š' + e.message);
  }
}

liff.init({ liffId: LIFF_ID })
  .then(() => {
    if (!liff.isLoggedIn()) {
      liff.login();
    } else {
      homeDiv.style.display = 'block';
    }
  })
  .catch(err => {
    alert('LIFF åˆå§‹åŒ–å¤±æ•—ï¼š' + err.message);
  });
</script>
</body>
</html>
